package edu.ucsf.sdm;

/**
 * This class implements leave-one-out cross validation for a specified model and training data set.
 * @author jladau
 */

public class CrossValidateModel {

	//rgsVarShort = list of short variable names (from header of data file)
	//rgsObsPred = each row gives an observed value and the prediction for that value if it left out of the model in fitting; first line is header
	
	private String rgsVarShort[];
	private String rgsObsPred[][];
	
	/**
	 * Constructor for mars.
	 * @param mar1 Initialized FitMARS_R object.
	 * @param rgsData Data.  Columns contain a variables.
	 * @param rgiPredictors List of columns with the predictors variables.
	 * @param iResponse Column with response variable.
	 * @param iIndex Column with the metric.
	 * @param sIndex Diversity metric to used: either "richness" or "shannon."
	 * @param sResponseTransform Transform to use or response variable.
	 * */
	public CrossValidateModel(FitMARS_R mar1, String rgsData[][], int rgiPredictors[], int iResponse, String sResponseTransform){
		
		//rgs1 = current data set being fit (has one observation omitted)
		//sPredictorValues = current predictor values (omitted observation)
		//dPrediction = current prediction
		
		String rgs1[][];
		String sPredictorValues;
		double dPrediction;
		
		//loading short variable names
		loadShortVars(rgsData);
		
		//initializing output
		rgsObsPred = new String[rgsData.length][2];
		rgsObsPred[0][0] = "OBSERVED_VALUE"; rgsObsPred[0][1] = "LEFT_OUT_PREDICTION";
		
		//looping through observations and removing one at a time
		for(int i=1;i<rgsData.length;i++){
			
			//updating progress
			System.out.println("Crossvalidation iteration " + i + " of " + rgsData.length + "...");
			
			//loading data set with one observation removed
			rgs1 = removeOneLine(rgsData,i);
		
			//fitting model
			mar1.fitModel(rgs1, rgiPredictors, iResponse, sResponseTransform);
			
			//loading current predictor values
			sPredictorValues = getPredictor(rgsData, i, rgiPredictors);
		
			//loading current prediction
			mar1.appendPredictorValues(sPredictorValues);
			
			//loading current prediction
			dPrediction = mar1.getPredictions()[0];
		
			//outputting results
			rgsObsPred[i][0] = rgsData[i][iResponse];
			rgsObsPred[i][1] = Double.toString(dPrediction);
			
			//clearing predictors
			mar1.clearPredictorValues();
		}
	}

	/**
	 * Constructor for lm.
	 * @param lm1 Initialized FitLM_R object.
	 * @param rgsData Data.  Columns contain a variables.
	 * @param sLM LM call
	 */
	public CrossValidateModel(FitLM_R lm1, String rgsData[][], int iResponse, String sLink, String sLM){
		
		//rgs1 = current data set being fit (has one observation omitted)
		//sPredictorValues = current predictor values (omitted observation)
		//dPrediction = current prediction
		
		String rgs1[][];
		String sPredictorValues;
		double dPrediction;
		
		//loading short variable names
		loadShortVars(rgsData);
		
		//initializing output
		rgsObsPred = new String[rgsData.length][2];
		rgsObsPred[0][0] = "OBSERVED_VALUE"; rgsObsPred[0][1] = "LEFT_OUT_PREDICTION";
		
		//looping through observations and removing one at a time
		for(int i=1;i<rgsData.length;i++){

			//updating progress
			System.out.println("Crossvalidation iteration " + i + " of " + rgsData.length + "...");
			
			//loading data set with one observation removed
			rgs1 = removeOneLine(rgsData,i);
		
			//fitting model
			lm1.fitModel(rgs1, sLM, sLink);
			
			//loading current predictor values
			sPredictorValues = getPredictor(rgsData, i);
		
			//loading current prediction
			lm1.appendPredictorValues(sPredictorValues);
			
			//loading current prediction
			lm1.loadPredictions(sLink);
			dPrediction = lm1.getPredictionsTransformed()[0];
		
			//outputting results
			rgsObsPred[i][0] = rgsData[i][iResponse];
			rgsObsPred[i][1] = Double.toString(dPrediction);
			
			//clearing predictors
			lm1.clearPredictorValues();
		}
	}
	
	/**
	 * Constructor for lm.
	 * @param lm1 Initialized FitLM_R object.
	 * @param rgsData Data.  Columns contain a variables.
	 * @param sLM LM call
	 */
	public CrossValidateModel(FitGLM_R glm1, String rgsData[][], int iResponse, String sLink, String sLM){
		
		//rgs1 = current data set being fit (has one observation omitted)
		//sPredictorValues = current predictor values (omitted observation)
		//dPrediction = current prediction
		
		String rgs1[][];
		String sPredictorValues;
		double dPrediction;
		
		//loading short variable names
		loadShortVars(rgsData);
		
		//initializing output
		rgsObsPred = new String[rgsData.length][2];
		rgsObsPred[0][0] = "OBSERVED_VALUE"; rgsObsPred[0][1] = "LEFT_OUT_PREDICTION";
		
		//looping through observations and removing one at a time
		for(int i=1;i<rgsData.length;i++){
	
			//updating progress
			System.out.println("Crossvalidation iteration " + i + " of " + rgsData.length + "...");
			
			//loading data set with one observation removed
			rgs1 = removeOneLine(rgsData,i);
		
			//fitting model
			glm1.fitModel(rgs1, sLM, sLink);
			
			//loading current predictor values
			sPredictorValues = getPredictor(rgsData, i);
		
			//loading current prediction
			glm1.appendPredictorValues(sPredictorValues);
			
			//loading current prediction
			glm1.loadPredictions();
			dPrediction = glm1.getPredictionsTransformed()[0];
		
			//outputting results
			rgsObsPred[i][0] = rgsData[i][iResponse];
			rgsObsPred[i][1] = Double.toString(dPrediction);
			
			//clearing predictors
			glm1.clearPredictorValues();
		}
	}

	/**
	 * Gets list of predictions when each observation is omitted.
	 * @return Matrix: first column gives observed value, second column gives predicted value when observation is omitted.
	 */
	public String[][] getPredictions(){
		return rgsObsPred;
	}

	/**
	 * Loads predictor string for current observation that was omitted.
	 * @param rgsData Data matrix.
	 * @param iRow Row from which observation is to be taken.
	 * @return Predictor in string format.
	 */
	private String getPredictor(String rgsData[][], int iRow){
		
		//sbl1 = output stringbuilder object
		
		StringBuilder sbl1;
		
		//initializing stringbuilder
		sbl1 = new StringBuilder();
		
		//looping through observations
		for(int j=0;j<rgsData[0].length;j++){
			
			//updating string
			sbl1.append(rgsVarShort[j] + ":"  + rgsData[iRow][j]);
			
			//terminating string appropriately
			if(j<rgsData[0].length-1){
				sbl1.append(",");
			}
		}
		
		//outputting result
		return sbl1.toString();
	}
	
	/**
	 * Loads predictor string for current observation that was omitted.
	 * @param rgsData Data matrix.
	 * @param iRow Row from which observation is to be taken.
	 * @param rgiPredictors List of columns with the predictors variables.
	 * @return Predictor in string format.
	 */
	private String getPredictor(String rgsData[][], int iRow, int rgiPredictors[]){
		
		//sbl1 = output stringbuilder object
		
		StringBuilder sbl1;
		
		//initializing stringbuilder
		sbl1 = new StringBuilder();
		
		//looping through observations
		for(int k=0;k<rgiPredictors.length;k++){
			
			//updating string
			sbl1.append(rgsVarShort[rgiPredictors[k]] + ":"  + rgsData[iRow][rgiPredictors[k]]);
			
			//terminating string appropriately
			if(k<rgiPredictors.length-1){
				sbl1.append(",");
			}
		}
		
		//outputting result
		return sbl1.toString();
	}
	
	/**
	 * Loads matrix of short variable names
	 * @param rgsData Data set.  Short variable names are assumed to be in the first row.
	 */
	private void loadShortVars(String rgsData[][]){
		
		//initializing short name array
		rgsVarShort = new String[rgsData[0].length];
		
		//adding names
		for(int j=0;j<rgsData[0].length;j++){
			rgsVarShort[j] = rgsData[0][j].split(":")[0];
		}	
	}
	
	/**
	 * Removes one observation from given data set.
	 * @param iRow Row to be removed.
	 * @param rgsData Data set.
	 * @return New data set with one row removed.
	 */
	private static String[][] removeOneLine(String rgsData[][], int iRow){
		
		//i1 = current output line
		//rgs1 = output
		
		String rgs1[][];
		int i1;
		
		//initializing output
		rgs1 = new String[rgsData.length-1][rgsData[0].length];
		
		//writing output
		i1 = 0;
		for(int i=0;i<rgsData.length;i++){
			if(i!=iRow){
				for(int j=0;j<rgsData[0].length;j++){
					rgs1[i1][j]=rgsData[i][j];
				}
				i1++;	
			}
		}
		
		//outputting result
		return rgs1;
	}
	
}
