package edu.ucsf.sdm;

import java.util.HashMap;
import java.util.Map;

/**
 * Object for running model selection.
 * @author jladau
 */

public class SelectModel {

	//mapBestModelPRESS(iVars) = returns the best model (model with lowest PRESS) with given number of variables
	//mapBestModelPRESS(iVars) = returns the best model (model with lowest BIC) with given number of variables
	//mapPRESS(sModel) = returns the press value of given model
	
	private Map<Integer,String> mapBestModelPRESS;
	private Map<Integer,String> mapBestModelBIC;
	private Map<String,Double> mapPRESS;
	private Map<String,Double> mapBIC;
	
	/**
	 * Constructor.
	 * @param rgsData Data file
	 * @param iMaxVars Maximum number of variables to consider
	 * @param sResponse Response variable name.
	 * @param rgsVars List of candidate covariates
	 */
	public SelectModel(String rgsData[][], int iMaxVars, String sResponse, String rgsVars[]){
		
		//flm1 = FitLM_R object
		//sblLM = current LM call
		//rgi1 = indices of variables currently being considered
		//cmb1 = current CombinatoricAlgorithms object
		//dPRESS = current press value
		//dPRESSMin = minimum PRESS value for current number of variables
		
		FitLM_R flm1;
		StringBuilder sblLM;
		int rgi1[];
		CombinatoricAlgorithms cmb1;
		double dPRESS; double dPRESSMin;
		
		//initializing FirLM_R object
		flm1 = new FitLM_R();
		
		//initializing maps
		mapBestModel = new HashMap<Integer,String>();
		mapPRESS = new HashMap<String,Double>();
		
		//initializing stringbuilder object
		sblLM = new StringBuilder();
		
		//loading intercept only model
		sblLM.append("lm(" + sResponse + "~1)");
		flm1.fitModel(rgsData, sblLM.toString());
		mapBestModel.put(0, sblLM.toString());
		mapPRESS.put(sblLM.toString(),flm1.getPRESS());
		
		//looping through numbers of variables
		for(int k=1;k<=iMaxVars;k++){
			
			//updating progress
			System.out.println("Analyzing models with " + k + " parameters...");
			
			//initializing combinatoric algorithms object
			cmb1 = new CombinatoricAlgorithms();
			
			//initializing minimum press value
			dPRESSMin = 99999999999999999999999.;
			
			//loading first subset
			rgi1 = cmb1.NEXKSB(rgsVars.length, k);
			
			//looping through subsets
			do{
				
				//loading lm call
				sblLM = new StringBuilder();
				sblLM.append("lm(" + sResponse + "~");
				for(int i=0;i<rgi1.length;i++){
					sblLM.append(rgsVars[rgi1[i]-1]);
					if(i<rgi1.length-1){
						sblLM.append("+");
					}
				}
				sblLM.append(")");
				
				//fitting model
				flm1.fitModel(rgsData, sblLM.toString());
				
				//saving PRESS value if appropriate
				dPRESS = flm1.getPRESS();
				if(dPRESS<dPRESSMin){
					mapBestModel.put(k, sblLM.toString());
					mapPRESS.put(sblLM.toString(), dPRESS);
					dPRESSMin = dPRESS;
				}
				
				//loading next subset
				rgi1 = cmb1.NEXKSB(rgsVars.length, k);
			}while(rgi1[0]!=-9999);
		}
		
		//terminating r connection
		flm1.closeR();
		
	}
	
	/**
	 * Returns the best model with the given number of covariates.
	 * @param iCovariates Number of covariates.
	 * @return Model
	 */
	public String getBestModel(int iCovariates){
		
		if(!mapBestModel.containsKey(iCovariates)){
			return "-9999";
		}else{
			return mapBestModel.get(iCovariates);
		}
	}
	
	/**
	 * Returns PRESS for given model
	 * @param iCovariates Number of covariates
	 * @return PRESS value
	 */
	public double getPRESS(int iCovariates){
		
		//sModel = model of with given number of covariates
		
		String sModel;
		
		if(!mapBestModel.containsKey(iCovariates)){
			return -9999;
		}else{
			sModel = mapBestModel.get(iCovariates);
			return mapPRESS.get(sModel);
		}
	}
}
