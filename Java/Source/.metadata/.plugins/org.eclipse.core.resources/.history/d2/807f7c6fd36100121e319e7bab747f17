package edu.ucsf.base;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import edu.ucsf.base.*;

/**
 * Fits beta-diversity models and performs cross validation by omitting pairs of observations
 * @author jladau
 */
public class BetaCrossValidate {

	//flm1 = FitLM_Apache object
	//dRSquared = rsquared value
	//dAdjustedRSquared = adjusted rsquared value
	//dTSS = total sum of squares
	//mapRowsNot(sSample) = returns list of rows that are for given sample
	//lstSamples = list of samples
	//rgsData = data
	//dPRESS = press statistic
	//rgdData = data in double format
	//lstPredictions = observed and predicted values
	
	private ArrayList<String> lstPredictions;
	private FitLM_Apache flm1;
	private double dRSquared;
	private double dAdjustedRSquared;
	private double dTSS;
	private double dPRESS;
	private Map<String,ArrayList<Integer>> mapRows;
	private ArrayList<String> lstSamples;
	private String[][] rgsData;
	private double[][] rgdData;
	
	/**
	 * Constructor
	 * @param rgsData Data
	 */
	public BetaCrossValidate(String rgsData[][]){
		
		//lst1 = list of rows with current sample
		//d1 = current data value
		
		double d1;
		ArrayList<Integer> lst1;
		
		//loading fitLM 
		flm1 = new FitLM_Apache(rgsData);
		
		//saving data
		this.rgsData = rgsData;
		rgdData = new double[rgsData.length-1][rgsData[0].length];
		for(int j=0;j<rgsData[0].length;j++){
			for(int i=1;i<rgsData.length;i++){
				
				//loading data in double format
				try{
					d1 = Double.parseDouble(rgsData[i][j]);
				}catch(Exception e){
					d1=-9999;
				}
				rgdData[i-1][j]=d1;
			}
		}
		
		//loading row map and list of samples
		mapRows = new HashMap<String,ArrayList<Integer>>();
		lstSamples = new ArrayList<String>();
		for(int i=1;i<rgsData.length;i++){
			for(int j=0;j<2;j++){
				if(mapRows.containsKey(rgsData[i][j])){
					mapRows.get(rgsData[i][j]).add(i);
				}else{
					lst1 = new ArrayList<Integer>();
					lst1.add(i);
					mapRows.put(rgsData[i][j], lst1);
				}
				if(!lstSamples.contains(rgsData[i][j])){
					lstSamples.add(rgsData[i][j]);
				}
			}
		}	
	}
	
	/**
	 * Checks if VIF is below threshold. Returns true if it is below threshold, false otherwise
	 * @param rgsPredictors Predictors to check.
	 * @param dThreshold Threshold.
	 * @return 
	 */
	public boolean checkVIF(String[] rgsPredictors, double dThreshold){
		return flm1.checkVIF(dThreshold);
	}

	public String[][] findPredictions(){
		
		//rgs1 = output
		
		String rgs1[][];
		
		rgs1 = new String[lstPredictions.size()][1];
		for(int i=0;i<lstPredictions.size();i++){
			rgs1[i][0]=lstPredictions.get(i);
		}
		return rgs1;
	}
	
	
	/**
	 * Finds Adjusted R^2 of current model.
	 * @return Adjusted R^2 value
	 */
	public double findAdjustedRSquared(){
		return dAdjustedRSquared;
	}

	public double findPRESS(){
		return dPRESS;
	}
	
	/**
	 * Finds R^2 of current model.
	 * @return R^2 value
	 */
	public double findRSquared(){
		return dRSquared;
	}

	/**
	 * Finds the total sum of squares
	 * @return Total sum of squares
	 */
	public double findTSS(){
		return dTSS;
	}
	
	/**
	 * Fits model with given response variable and predictors. Data are loaded first for given model.   
	 * @param sResponse Response variable name.
	 * @param rgsPredictors Predictor names.
	 */
	public void fitModel(String sResponse, String[] rgsPredictors){
		
		//sSample1 = current first sample
		//sSample2 = current second sample
		//lstDataTruncated = data set with all rows containing current samples removed
		//flm2 = fitLM object being used for cross validation
		//rgd1 = current predicted value
		//rgdX = values of environmental variables where prediction is to be made
		//i1 = row of data for prediction
		//dSSE = sum of squares due to error
		//dObservation = current observation
		
		String sSample1; String sSample2;
		ArrayList<double[]> lstDataTruncated;
		FitLM_Apache flm2;
		double rgd1[]; double rgdX[][];
		int i1;
		double dSSE; double dObservation;
		
		//initializing predictions
		lstPredictions = new ArrayList<String>();
		lstPredictions.add("PREDICTED,OBSERVED");
		
		//checking if null case
		if(rgsPredictors==null){
			dTSS = flm1.findTSS(sResponse);
			return;
		}
		
		//loading non-cross validation results
		flm1.fitModel(sResponse, rgsPredictors);
		dRSquared = flm1.findRSquared();
		dAdjustedRSquared = flm1.findAdjustedRSquared();
		dTSS = flm1.findTSS(sResponse);
		
		//loading cross validation results: looping through pairs of samples
		dSSE=0;
		for(int i=1;i<rgsData.length;i++){
			
			//loading current pair of samples
			sSample1 = rgsData[i][0];
			sSample2 = rgsData[i][1];
				
			//saving prediction row
			i1 = i;
			
			//loading truncated data set and prediction row
			//i1 = -9999;
			lstDataTruncated = new ArrayList<double[]>();
			for(int k=1;k<rgsData.length;k++){
				
				//updating truncated data
				if(!rgsData[k][0].equals(sSample1) && !rgsData[k][0].equals(sSample2)){
					if(!rgsData[k][1].equals(sSample1) && !rgsData[k][1].equals(sSample2)){
						lstDataTruncated.add(rgdData[k-1]);
					}
				}
				
				//checking if this is the prediction row
				//if(rgsData[k][0].equals(sSample1) && rgsData[k][1].equals(sSample2)){
				//	i1 = k;
				//}
				//if(rgsData[k][0].equals(sSample2) && rgsData[k][1].equals(sSample1)){
				//	i1 = k;
				//}
			}
			
			//loading cross validation modeling object
			flm2 = new FitLM_Apache(lstDataTruncated, flm1.getColumnMap());
			flm2.fitModel(sResponse, rgsPredictors);

			//loading environmental values for prediction
			rgdX = flm1.findPredictors(i1, rgsPredictors, sResponse);
			
			//loading observed response for prediction
			dObservation = flm1.findObservation(i1, sResponse);
			
			//loading prediction for left out pair
			rgd1 = flm2.findPrediction(rgdX);
			
			//updating sse
			dSSE += (rgd1[0]-dObservation)*(rgd1[0]-dObservation);
			
			//updating predictions list
			lstPredictions.add(rgd1[0] + "," + dObservation);
			
		}
		
		//saving press statistics
		dPRESS = dSSE;
	}
}
