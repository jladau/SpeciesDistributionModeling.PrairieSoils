package edu.ucsf.sdm;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import ucar.ma2.Array;
import ucar.ma2.ArrayDouble;
import ucar.ma2.DataType;
import ucar.ma2.Index;
import ucar.ma2.InvalidRangeException;
import ucar.nc2.*;

/**
 * Wrapper for writing and reading geographic information from netCDF files.
 * @author jladau
 */
public class NetCDF_IO {
	
	//map1(sVarName,sValue) = returns index of value for given variable name and value
	//var1 = variable of interest
	//ncf1 = NetCDF file
	//rgiShape = shape (assuming extracting one record at a time)
	//sUnits = units of variable
	
	private NetcdfFile ncf1 = null;
	private Map<String, Integer> map1 = null;
	private Variable var1 = null;
	private int rgiShape[];
	private String sUnits;
	
	/**
	 * Constructor
	 * @param sInPath Path to NetCDF file being read.
	 */
	public NetCDF_IO(String sInPath){
		
		//netCDF_IO constructor
		
		//opening file
		try {
			ncf1 = NetcdfFile.open(sInPath);
		} catch (IOException ioe) {
			System.out.println("ERROR.");
	    }	
	}
	
	/**
	 * Builds a netcdf reader using the first variable found within the netCDF file
	 */
	public void buildReaderFirstVar(){
		
		//rgsVars = list of variables
		
		String rgsVars[];
		
		//loading list of variables
		rgsVars = this.getCDFVars();
		
		//looping through variables to find the one that is not latitude or longitude
		for(int j=0;j<rgsVars.length;j++){
			if(rgsVars[j].equals("lat")==false && rgsVars[j].equals("lon")==false){
				this.buildReader(rgsVars[j]);
				break;
			}
		}
	}
	
	/**
	 * Gets a list of variables in the NetCDF file
	 * @return A string array giving the list of variables.
	 */
	public String[] getCDFVars(){
		
		//rgs1 = output
		//lst1 = list of variables
		//itr1 = list iterator
		//i1 = number of variables
		//rgs1 = output
		//var2 = current variable
		
		Variable var2;
		int i=0;
		List<Variable> lst1;
		Iterator<Variable> itr1;
		int i1=0;
		String rgs1[];
		
		//loading list of variables
		lst1 = this.ncf1.getVariables();
		
		//looping through variables
		for(itr1 = lst1.iterator(); itr1.hasNext();){
			itr1.next();
			i1++;
		}
		
		//outputting results
		rgs1 = new String[i1];
		for(itr1 = lst1.iterator(); itr1.hasNext();){
			var2 = (Variable) itr1.next();
			rgs1[i] = var2.getShortName();
			i++;
		}
		
		//outputting result
		return rgs1;	
	}
	
	/**
	 * Builds a reader that returns values for specified variable
	 * @param sVar Variable for which to build reader.
	 */
	public void buildReader(String sVar){
		
		//varArg = current argument variable
		//sInPath = path to NetCDF file
		//rgs2 = list of variables for arguments
		//sVarArg = name of current argument variable
		//ary1 = current data array
		
		Variable varArg;
		String rgs2[];
		String sVarArg;
		Array ary1 = null;
		
		//initializing map1
		map1 = new HashMap<String,Integer>();	
		
		//loading variable
		var1 = ncf1.findVariable(sVar);
		
		//loading list of variable names
		rgs2 = var1.getDimensionsString().split(" ");
		
		//looping through variables
		for(int i=0;i<rgs2.length;i++){
			
			//loading name of variable
			sVarArg = rgs2[i];
			
			//loading variable
			varArg = ncf1.findVariable(sVarArg);
			
			//loading array
			try {
				ary1 = varArg.read().reduce();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			//looping through array
			for(int j=0;j<ary1.getShape()[0];j++){
				
				//updating map1
				map1.put(sVarArg + ":" + ary1.getFloat(j), j);	
			}
		}
		
		//initializing rgiShape
		rgiShape = var1.getShape();
		for(int i=0;i<rgiShape.length;i++){
			rgiShape[i] = 1;
		}
		
		//loading units
		sUnits = var1.getUnitsString();	
	}

	/**
	 * Gets the units for the current response variable.
	 * @return Name of the units for the current response variable.
	 */
	public String getUnits(){
		
		return sUnits;
	}
	
	/**
	 * Closes NetCDF file.
	 */
	public void closeNetCDF(){
	
		try{
		    this.ncf1.close();
		}catch (IOException ioe) {
		    System.out.println("ERROR: CloseCDF method.");
		}
	}
	
	/**
	 * Reads value of current variable at the given value of the arguments
	 * @param sArgValues Arguments at which value should be obtained: e.g., "lat:30.25,lng:20.25,time:2."
	 * @return Value at given arguments.
	 */
	public double readValue(String sArgValues){
		
		//rgs1 = list of arguments and values
		//bClose = flag for whether to close file
		//i2 = lookup index of current argument
		//rgiOrigin = lookup array
		//ary1 = current data array
		
		String rgs1[]; 
		int i1; int i2;
		int rgiOrigin[];
		Array ary1 = null;
		
		//loading arguments
		rgs1 = sArgValues.split(",");
		
		//loading arguments
		rgiOrigin = new int[rgs1.length];
		for(int i=0;i<rgs1.length;i++){
			
			//finding index of current variable
			i1 = var1.findDimensionIndex(rgs1[i].split(":")[0]);
			
			//checking if all records should be collected for variable
			if(rgs1[i].endsWith("*")==true){
				rgiOrigin[i1] = 0;
			}else{
			
				//finding value for current variable
				if(map1.containsKey(rgs1[i])==false){
					System.out.println("ERROR: key not found (" + rgs1[i] + ").");
					return -9999;
				}else{
					i2 = map1.get(rgs1[i]);
				}
				
				//loading lookup array
				rgiOrigin[i1] = i2;
			}
		}
		
		//looking up value and loading result in array format
		try {
			ary1 = var1.read(rgiOrigin, rgiShape).reduce();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InvalidRangeException e) {
			e.printStackTrace();
		}
		
		//outputting result
		return ary1.getDouble(0);
	}
	
	/**
	 * Writes given grid (in ascii grid format) to netCDf file at path sOutPath
	 * @param rgdGrid Grid being written.
	 * @param sVarName Name of the variable being written.
	 * @param sVarUnits Units of the variable being written.
	 * @param sOutPath Path of file being written.
	 */
	public static void writeNetCDF(double rgdGrid[][], String sVarName, String sVarUnits, String sOutPath) {
		
		//sVarName = name of variable
		//sVarUnits = units of variable
		//iLat = latitude dimension
		//iLng = longitude dimension
		//rga1 = current data array
		//cdf1 = netcdf file
		//dimLat = latitude dimension
		//dimLng = longitude dimension
		//lst1 = list of dimensions
		//ary1 = current data being written
		//rgx1 = index array
		//dCellSize = cell size in degrees
		//rgiO = origin
		
		int iLat; int iLng;
		ArrayDouble rga1;
		ArrayList<Dimension> lst1;
		Index rgx1;
		int i; int j;
		double dCellSize;
		int rgiO[];
		NetcdfFileWriteable cdf1 = null;
		Dimension dimLat; Dimension dimLng;
		
		//loading latitude and longitude dimension
		iLat = rgdGrid.length; iLng = rgdGrid[0].length;
		
		//loading cell size
		dCellSize = 180./((double) iLat);
		
		//initializing file
		try {
			cdf1 = NetcdfFileWriteable.createNew(sOutPath, false);
		} catch (IOException e1) {
			e1.printStackTrace();
		}	
		
		//adding dimensions
		dimLat = cdf1.addDimension("lat", iLat);
		dimLng = cdf1.addDimension("lon", iLng);
		lst1 = new ArrayList<Dimension>();
		lst1.add(dimLng);
		cdf1.addVariable("lon",DataType.FLOAT, lst1);
		cdf1.addVariableAttribute("lon","units","degrees_east");
		lst1 = new ArrayList<Dimension>();
		lst1.add(dimLat);		
		cdf1.addVariable("lat",DataType.FLOAT, lst1);
		cdf1.addVariableAttribute("lat","units","degrees_north");
		
		//adding variables
		lst1 = new ArrayList<Dimension>();
		lst1.add(dimLat);
		lst1.add(dimLng);
		cdf1.addVariable(sVarName,DataType.FLOAT, lst1);
		cdf1.addVariableAttribute(sVarName,"units",sVarUnits);
		cdf1.addVariableAttribute(sVarName,"missing_value",-9999);
		
		//creating file
		try {
			cdf1.create();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		//adding latitude data
		rga1 = new ArrayDouble.D1(iLat);
		rgx1 = rga1.getIndex();
		for(i=0; i<iLat; i++) {
			rga1.setDouble(rgx1.set(i), -90 + dCellSize/2. + ((double) i)*dCellSize);
		}
		rgiO = new int[2];
		try {
			try {
				cdf1.write("lat", rgiO, rga1);
			} catch (IOException e) {
				e.printStackTrace();
			}
		} catch (InvalidRangeException e) {
			System.out.println("ERROR!");
		}
		
		//adding longitude data
		rga1 = new ArrayDouble.D1(iLng);
		rgx1 = rga1.getIndex();
		for(i=0; i<iLng; i++) {
			rga1.setDouble(rgx1.set(i), -180 + dCellSize/2. + ((double) i)*dCellSize);
		}
		rgiO = new int[2];
		try {
			try {
				cdf1.write("lon", rgiO, rga1);
			} catch (IOException e) {
				e.printStackTrace();
			}
		} catch (InvalidRangeException e) {
			System.out.println("ERROR!");
		}
		
		//outputting grid
		rga1 = new ArrayDouble.D2(iLat, iLng);
		rgx1 = rga1.getIndex();
		for(i=0; i<iLat; i++) {
			for(j=0; j<iLng; j++) {
				rga1.setDouble(rgx1.set(i,j), rgdGrid[iLat-i-1][j]);
		    }
		}
		rgiO = new int[2];
		try{
			try {
				cdf1.write(sVarName, rgiO, rga1);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}catch (InvalidRangeException e) {
			System.out.println("ERROR.");
		}		
		
		//closing file
		try {
			cdf1.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}