package edu.ucsf.sdm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.rosuda.JRI.Rengine;

/**
 * This class provides wrapper functions for fitting glm with R
 * @author jladau
 */
public class FitGLM_R {

	//ren1 = r engine
	//mapVarType(sShortName) = returns the variable type for the given variable
	//mapPredictors(sVarShort) = returns current predictor values (for prediction)
	//rgdPredictions = array of current predictions
	//sLink = link function
	
	private String sLink;
	private Map<String,ArrayList<String>> mapPredictors;
	private Rengine ren1;
	private Map<String,String> mapVarType;
	private double rgdPredictions[];
	
	/**
	 * Constructor
	 */
	public FitGLM_R(){
		
		//initializing r object
		ren1 = new Rengine (new String [] {"--vanilla"}, false, null);
		if (ren1.waitForR() == false)
        {
            System.out.println("ERROR: FitGLM_R.constructor");
            return;
        }
		ren1.eval("library(MPV)");
		ren1.eval("library(car)");
		
		//*************************
		//System.out.println("library(MPV)");
		//*************************
	}
	
	/**
	 * Appends given predictor values to predictor values stored in mapPredictors.
	 * @param sPredValues Predictor values being appended. Format is sShortName1:Value1,sShortName2:Value2,sShortName3:Value3,...
	 */
	public void appendPredictorValues(String sPredictorValues){
		
		//rgs1 = predictors string in split format
		//rgs2 = current predictor name and value
		//sVarShort = current predictor
		//lst1 = current list of observations
		
		ArrayList<String> lst1;
		String rgs1[]; String rgs2[];
		String sVarShort;
		
		//loading rgs1
		rgs1 = sPredictorValues.split(",");
		
		//looping through predictors
		for(int i=0;i<rgs1.length;i++){
			
			//loading array of current short name and value
			rgs2 = rgs1[i].split(":");
		
			//loading current short variable name
			sVarShort = rgs2[0];
			
			//updating mapPredictors
			if(mapPredictors.containsKey(sVarShort)){
				
				//loading current list
				lst1 = mapPredictors.get(sVarShort);
				
				//updating list
				lst1.add(rgs2[1]);	
				mapPredictors.put(sVarShort,lst1);
			}else{
				lst1 = new ArrayList<String>(185000);
				
				//updating list
				lst1.add(rgs2[1]);
				mapPredictors.put(sVarShort,lst1);
			}
		}
	}

	/**
	 * Clears predictor values.
	 */
	public void clearPredictorValues(){
		mapPredictors.clear();
	}
	
	/**
	 * Closes attached R objects.
	 */
	public void closeR(){
		ren1.end();
	}
	
	/**
	 * Finds goodness of fit for current model.
	 * @return P-value for goodness of fit. 
	 */
	public double findGoodnessOfFit(){
		
		//d1 = output
		
		double d1;
		
		try{
			
			//checking goodness of fit
			d1 = ren1.eval("1-pchisq(glm1$deviance, glm1$df.residual)").asDouble();
		}catch(Exception e){
		
			//error
			d1 = -9999;
		}
		
		//returning result
		return d1;
	}

	/**
	 * Loads data into vectors for fitting using glm and fits glm.
	 * @param rgsData Data matrix. Columns represent predictors or the response variable.  Rows represent different observations.  First row is a header row. Header string should be of the following format ShortName:LongName:VariableType.  The VariableType is either "continuous" or "categorical."
	 * @param sLink Link function.
	 * @param sGLM GLM call
	 */
	public void fitModel(String rgsData[][], String sGLM, String sLink){
		
		//sbl1 = string builder object for current vector being loaded
		//rgs1 = current header string in split format
		
		StringBuilder sbl1;
		String rgs1[];
		
		//loading link
		this.sLink=sLink;
		
		//formatting headers and loading variable type map
		mapVarType = new HashMap<String,String>();
		for(int j=0;j<rgsData[0].length;j++){
			
			//splitting header
			rgs1 = rgsData[0][j].split(":");
			
			//loading variable type
			if(rgs1.length==2){	
				mapVarType.put(rgs1[0], rgs1[1]);
			}else{
				mapVarType.put(rgs1[0], "continuous");
			}
				
			//updating header
			rgsData[0][j]=rgs1[0];
		}
		
		//looping through variables
		for(int j=0;j<rgsData[0].length;j++){
			
			//checking if variable should be loaded
			if(!sGLM.contains(rgsData[0][j])){
				continue;
			}
			
			//initializing string builder
			sbl1 = new StringBuilder();
			sbl1.append(rgsData[0][j] + "=c(" + rgsData[1][j]);
			
			//creating string
			for(int i=2;i<rgsData.length;i++){
				sbl1.append("," + rgsData[i][j]);
			}
			sbl1.append(")");
			
			//loading string into r
			ren1.eval(sbl1.toString());
			
			//checking if factor
			if(mapVarType.get(rgsData[0][j]).equals("categorical")){
				ren1.eval(rgsData[0][j] + "=as.factor(" + rgsData[0][j] + ")");
			}
		}

		//clearing glm1
		ren1.eval("remove(glm1)");
		
		//clearing warnings
		ren1.eval("assign(\"last.warning\", NULL, envir = baseenv())");
		
		//running initial glm
		ren1.eval("glm1=" + sGLM);
		
		//running model selection
		//******************************
		//ren1.eval("glm1=step(glm1,direction=c(\"both\"))");
		//******************************
		
		//checking for warnings
		/*
		if(ren1.eval("last.warning").toString().equals("[NULL ]")==false || ren1.eval("glm1$th.warn").toString().equals("[NULL ]")==false){
				
			//clearing glm1: algorithm did not converge or other error
			ren1.eval("remove(glm1)");	
			
			//outputting error
			System.out.println("ERROR: FitGLM_R.fitModel");
		}
		*/
		
		//initializing prediction frame
		initializePredFrame(rgsData);
	}
	
	/**
	 * Fits glm without loading data
	 * @param sGLM GLM call
	 * @param sLink Link function.
	 */
	public void fitModelWithLoadedData(String sGLM, String sLink){
		
		//loading link
		this.sLink=sLink;
		
		//clearing glm1
		ren1.eval("remove(glm1)");
		
		//clearing warnings
		ren1.eval("assign(\"last.warning\", NULL, envir = baseenv())");
		
		//running initial glm
		sGLM+="grhdnsjfd";
		ren1.eval("glm1=" + sGLM.replace(")grhdnsjfd", ",data=fra0)"));
		
		//checking for warnings
		if(ren1.eval("last.warning").toString().equals("[NULL ]")==false || ren1.eval("glm1$th.warn").toString().equals("[NULL ]")==false){
				
			//clearing glm1: algorithm did not converge or other error
			ren1.eval("remove(glm1)");	
			
			//outputting error
			System.out.println("ERROR: FitGLM_R.fitModel");
		}
	}

	/**
	 * Gets estimated coefficients for the current glm model stored in the glm1 variable in R.
	 * @return Array of coefficients.
	 */
	public String[][] getCoefficients(){
	
		//rgsOut = output
		//iRows = number of coefficients estimated
		//rgs1 = coefficient names
		//rgd1 = coefficient values
		//i1 = current output row
		
		String rgsOut[][]; String rgs1[];
		int iRows; int i1;
		double rgd1[];
		
		//checking for error
		if(ren1.eval("length(coefficients(glm1))")==null){
			rgsOut=new String[1][1];
			rgsOut[0][0]="-9999";
			return rgsOut;
		}
		
		//loading coefficient values
		rgd1 = ren1.eval("coefficients(glm1)").asDoubleArray();
		
		//loading number of rows
		iRows=0;
		for(int i=0;i<rgd1.length;i++){
			if(!Double.toString(rgd1[i]).equals("NaN")){
				iRows++;
			}	
		}
			
		//initializing output
		rgsOut = new String[iRows][2];
		
		//loading coefficient names
		rgs1 = ren1.eval("names(coefficients(glm1))").asStringArray();
		
		//outputting results
		i1=0;
		for(int i=0;i<rgsOut.length;i++){
			if(!Double.toString(rgd1[i]).equals("NaN")){
				rgsOut[i1][0]=rgs1[i];
				rgsOut[i1][1]=Double.toString(rgd1[i]);
				i1++;
			}
		}
		
		//returning result
		return rgsOut;
	}
	
	/**
	 * Loads data for repeated glm calls
	 * @param rgsData Data set
	 */
	public void loadData(String rgsData[][]){
		
		//sbl1 = string builder object for current vector being loaded
		//rgs1 = current header string in split format
		//rgd1 = current list of values
		
		StringBuilder sbl1;
		String rgs1[];
		double rgd1[];
		
		//formatting headers and loading variable type map
		mapVarType = new HashMap<String,String>();
		for(int j=0;j<rgsData[0].length;j++){
			
			//splitting header
			rgs1 = rgsData[0][j].split(":");
			
			//loading variable type
			if(rgs1.length==2){	
				mapVarType.put(rgs1[0], rgs1[1]);
			}else{
				mapVarType.put(rgs1[0], "continuous");
			}
				
			//updating header
			rgsData[0][j]=rgs1[0];
		}
		
		//looping through variables
		for(int j=0;j<rgsData[0].length;j++){
			
			//initializing array of values
			rgd1 = new double[rgsData.length-1];
			
			//looping through values
			for(int i=1;i<rgsData.length;i++){
				try{
					rgd1[i-1]=Double.parseDouble(rgsData[i][j]);
				}catch(Exception e){
				}
			}
			
			//assigning variable name
			ren1.assign(rgsData[0][j], rgd1);
		}
		
		sbl1 = new StringBuilder();
		sbl1.append("fra0=data.frame(");
		for(int j=0;j<rgsData[0].length;j++){
			if(j>0){
				sbl1.append(",");
			}
			sbl1.append(rgsData[0][j]);
		}
		sbl1.append(",check.names=FALSE)");
		ren1.eval(sbl1.toString());
	}

	/**
	 * Initializes data frame for making predictions.
	 */
	private void initializePredFrame(String rgsData[][]){
		
		//s1 = R data frame string
		//sVarShort = current predictor
		
		String sVarShort; String s1=null;
		
		//looping through predictors
		for(int j=0;j<rgsData[0].length;j++){
			
			//loading current short variable name
			sVarShort = rgsData[0][j];
			
			//loading current element of data frame
			ren1.eval(sVarShort + "=c(1.)");
			
			//****************************
			//System.out.println(sVarShort + "=c(1.)");
			//****************************
			
			//updating command for making data frame
			if(s1==null){
				s1="fra1=data.frame(" + sVarShort;
			}else{
				s1+=","+sVarShort;
			}
		}
		
		//creating data frame
		s1+=",check.names=FALSE,check.rows=FALSE)";
		ren1.eval(s1);
		
		//**********************
		//System.out.println(s1);
		//**********************
		
		//initializing predictors map
		mapPredictors = new HashMap<String,ArrayList<String>>();
	}
	
	/**
	 * Applies inverse transform using transform in sResponseTransform.
	 * @param dValue Value to be transformed.
	 * @param sLink Link function
	 * @return Transformed value.
	 */
	private double applyInverseLink(double dValue){
		
		if(sLink.equals("log")){
			return Math.exp(dValue);
		}else if(sLink.equals("sqrt")){
			return dValue*dValue;
		}else if(sLink.equals("inverse")){
			return 1./dValue;
		}else if(sLink.equals("identity")){
			return dValue;
		}else if(sLink.equals("logit")){
			return 1./(1.+Math.exp(-dValue));
		}
		return -9999.;
	}

	/**
	 * Gets predicted values.
	 * @return Array of predicted values transformed according to link.
	 */
	public double[] getPredictionsTransformed(){
		return rgdPredictions;
	}

	/**
	 * Gets predicted values.
	 * @return Array of predicted values in original scale
	 */
	public double[] getPredictionsOriginal(){
		
		//rgd1 = transformed predictions
		
		double rgd1[];
		
		rgd1 = new double[rgdPredictions.length];
		for(int i=0;i<rgdPredictions.length;i++){
			rgd1[i]=this.applyInverseLink(rgdPredictions[i]);
		}
		return rgd1;
	}
}
