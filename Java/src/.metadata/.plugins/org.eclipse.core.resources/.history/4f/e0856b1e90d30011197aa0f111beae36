package edu.ucsf.sdm;

public class DrawMap {

	/** draws diversity map using the model fit in the given AssembleFirst object */
	
	//rgdMap = map
	//rgdMapStError = map showing standard errors of the estimates
	//rgdLatGradient = first column with latitude, second column with estimated mean richness, third column with lower bound for 95% CI, fourth column with upper bound for 95% CI
	
	private double rgdMap[][];
	private double rgdMapStError[][];
	private double rgdLatGradient[][];
	
	public DrawMap(FitLM_R lm1, String sDir, String rgsData[][], String sSuffix, String sResponseTransform, String sPredictorValuesSuffix){
		
		//constructor
		
		//sResponseTransform = "identity" for identity, "log" for log
		//dLat = current latitude
		//dLng = current longitude
		//sArgValues = current argument values
		//sPredValues = current predicted values
		//prd1 = PredictorValues object
		//rgdPredictions = predictions
		//rgdCI = confidence interval for mean observation
		//rgdStErrors = standard errors of predictions
		//i1 = current row in predictions array
		//sPredValues = current predicted values
		//sElevationTime = elevation and time for predictions
		
		double dLat = 90.25; double dLng;
		String sArgValues; String sPredValues; String sElevationTime; String sPredictorValues;
		PredictorValues prd1;
		double rgdPredictions[]; double rgdStErrors[]; double rgdCI[];
		int i1=0;
		
		//loading predictor values and suffix
		if(sPredictorValuesSuffix.contains(";")){
			sPredictorValues = sPredictorValuesSuffix.split(";")[0];
			sElevationTime = sPredictorValuesSuffix.split(";")[1];
		}else{
			sPredictorValues = sPredictorValuesSuffix;
			sElevationTime = null;
		}
		
		//initializing PredictorValues object
		prd1 = new PredictorValues(sDir, rgsData, sSuffix, sPredictorValues);
		
		//initializing map
		rgdMap = new double[360][720];
		rgdMapStError = new double[360][720];
		rgdLatGradient = new double[360][4];
		
		//looping through latitudes
		for(int i=0;i<360;i++){
			
			//updating latitude
			dLat-=0.5;

			//updating latitude gradient array
			rgdLatGradient[i][0] = dLat;
			
			//initializing longitude
			dLng = -180.25;
			
			//updating progress
			System.out.println("Latitude:" + dLat);
			
			//looping through longitude
			for(int j=0;j<720;j++){
				
				//updating longitude
				dLng+=0.5;
				
				//loading arguments
				if(sElevationTime==null){
					sArgValues = "lat:"  + dLat + ",lon:" + dLng;
				}else{
					sArgValues = "lat:"  + dLat + ",lon:" + dLng + "," + sElevationTime;
				}
				
				//loading predictor values
				sPredValues = prd1.GetValues(sArgValues, true);
				
				//checking if error value
				if(sPredValues.equals("-9999")){
				
					//putting error value
					rgdMap[i][j]=-9999.;
					rgdMapStError[i][j]=-9999.;
				}else{
				
					//loading predictor value
					lm1.appendPredictorValues(sPredValues);
				}
			}
			
			//loading predicted values
			lm1.loadPredictions();
			rgdPredictions = lm1.getPredictionsTransformed();
			rgdStErrors = lm1.getStErrorPredictionsTransformed();
			rgdCI = lm1.getCITransformed();
		
			//checking for error
			if(rgdPredictions[0]==-9999){
				rgdLatGradient[i][1] = -9999;
				rgdLatGradient[i][2] = -9999;
				rgdLatGradient[i][3] = -9999;	
			}else{
				
				//updating map
				i1=0;
				for(int j=0;j<720;j++){
					if(rgdMap[i][j]!=-9999.){
						rgdMap[i][j]=rgdPredictions[i1];
						rgdMapStError[i][j]=rgdStErrors[i1];
						i1++;
					}
				}
				rgdLatGradient[i][1] = rgdCI[0];
				rgdLatGradient[i][2] = rgdCI[1];
				rgdLatGradient[i][3] = rgdCI[2];	
			}
				
			//clearing predictor values
			lm1.clearPredictorValues();
		}
	
		//closing PredictorValues object
		prd1.Close();
	}
	
	public DrawMap(FitMARS_R mar1, String sDir, String rgsData[][], String sSuffix, String sPredictorValuesSuffix){
		
		//constructor
		
		//sResponseTransform = "identity" for identity, "log" for log
		//dLat = current latitude
		//dLng = current longitude
		//sArgValues = current argument values
		//sPredValues = current predicted values
		//sElevationTime = elevation and time for predictions
		//prd1 = PredictorValues object for northern hemisphere
		//rgd1 = predictions
		//i1 = current row in predictions array
		
		double dLat = 90.25; double dLng;
		String sArgValues; String sPredValues; String sElevationTime; String sPredictorValues;
		PredictorValues prd1;
		double rgd1[];
		int i1=0;
		
		//initializing map and error matrices
		rgdMap = new double[360][720];
		
		//loading predictor values and suffix
		if(sPredictorValuesSuffix.contains(";")){
			sPredictorValues = sPredictorValuesSuffix.split(";")[0];
			sElevationTime = sPredictorValuesSuffix.split(";")[1];
		}else{
			sPredictorValues = sPredictorValuesSuffix;
			sElevationTime = null;
		}
		
		//initializing PredictorValues objects
		prd1 = new PredictorValues(sDir, rgsData, sSuffix, sPredictorValues);
		
		//looping through latitudes
		for(int i=0;i<360;i++){
			
			//updating latitude
			dLat-=0.5;
			
			//initializing longitude
			dLng = -180.25;
			
			//updating progress
			System.out.println("Latitude:" + dLat);
			
			//looping through longitude
			for(int j=0;j<720;j++){
				
				//updating longitude
				dLng+=0.5;
				
				//loading arguments
				if(sElevationTime==null){
					sArgValues = "lat:"  + dLat + ",lon:" + dLng;
				}else{
					sArgValues = "lat:"  + dLat + ",lon:" + dLng + "," + sElevationTime;
				}
				
				//loading predictor values
				sPredValues = prd1.GetValues(sArgValues, true);
				
				//checking if error value
				if(sPredValues.equals("-9999")){
				
					//putting error value
					rgdMap[i][j]=-9999.;
					
				}else{
			
					//loading predictor value
					mar1.appendPredictorValues(sPredValues);	
				}
			}
			
			//loading predicted values
			rgd1 = mar1.getPredictions();
		
			//updating map and latitude gradient
			i1=0;
			for(int j=0;j<720;j++){
				if(rgdMap[i][j]!=-9999.){
					rgdMap[i][j]+=rgd1[i1];
					i1++;
				}
			}
			
			//clearing predictor values
			mar1.clearPredictorValues();
		}
	
		//closing PredictorValues object
		prd1.Close();
	}

	public DrawMap(FitGLM_R glm1, String sDir, String rgsData[][], String sSuffix, String sResponseTransform, String sPredictorValuesSuffix){
		
		//constructor
		
		//sResponseTransform = "identity" for identity, "log" for log
		//dLat = current latitude
		//dLng = current longitude
		//sArgValues = current argument values
		//sPredValues = current predicted values
		//prd1 = PredictorValues object
		//rgdPredictions = predictions
		//i1 = current row in predictions array
		//sPredValues = current predicted values
		//sElevationTime = elevation and time for predictions
		
		double dLat = 90.25; double dLng;
		String sArgValues; String sPredValues; String sElevationTime; String sPredictorValues;
		PredictorValues prd1;
		double rgdPredictions[];
		int i1=0;
		
		//loading predictor values and suffix
		if(sPredictorValuesSuffix.contains(";")){
			sPredictorValues = sPredictorValuesSuffix.split(";")[0];
			sElevationTime = sPredictorValuesSuffix.split(";")[1];
		}else{
			sPredictorValues = sPredictorValuesSuffix;
			sElevationTime = null;
		}
		
		//initializing PredictorValues object
		prd1 = new PredictorValues(sDir, rgsData, sSuffix, sPredictorValues);
		
		//initializing map
		rgdMap = new double[360][720];
		rgdMapStError = new double[360][720];
		rgdLatGradient = new double[360][4];
		
		//looping through latitudes
		for(int i=0;i<360;i++){
			
			//updating latitude
			dLat-=0.5;
	
			//updating latitude gradient array
			rgdLatGradient[i][0] = dLat;
			
			//initializing longitude
			dLng = -180.25;
			
			//updating progress
			System.out.println("Latitude:" + dLat);
			
			//looping through longitude
			for(int j=0;j<720;j++){
				
				//updating longitude
				dLng+=0.5;
				
				//loading arguments
				if(sElevationTime==null){
					sArgValues = "lat:"  + dLat + ",lon:" + dLng;
				}else{
					sArgValues = "lat:"  + dLat + ",lon:" + dLng + "," + sElevationTime;
				}
				
				//loading predictor values
				sPredValues = prd1.GetValues(sArgValues, true);
				
				//checking if error value
				if(sPredValues.equals("-9999")){
				
					//putting error value
					rgdMap[i][j]=-9999.;
					//rgdMapStError[i][j]=-9999.;
				}else{
				
					//loading predictor value
					glm1.appendPredictorValues(sPredValues);
				}
			}
			
			//loading predicted values
			glm1.loadPredictions();
			rgdPredictions = glm1.getPredictionsOriginal();
			
			//checking for error
			if(rgdPredictions[0]==-9999){
				//rgdLatGradient[i][1] = -9999;
				//rgdLatGradient[i][2] = -9999;
				//rgdLatGradient[i][3] = -9999;	
			}else{
				
				//updating map
				i1=0;
				for(int j=0;j<720;j++){
					if(rgdMap[i][j]!=-9999.){
						rgdMap[i][j]=rgdPredictions[i1];
						//rgdMapStError[i][j]=rgdStErrors[i1];
						i1++;
					}
				}
				//rgdLatGradient[i][1] = rgdCI[0];
				//rgdLatGradient[i][2] = rgdCI[1];
				//rgdLatGradient[i][3] = rgdCI[2];	
			}
				
			//clearing predictor values
			glm1.clearPredictorValues();
		}
	
		//closing PredictorValues object
		prd1.Close();
	}

	/**
	 * Gets estimated map
	 * @return Estimated map
	 */
	public double[][] getMap(){
		return rgdMap;
	}
	
	/**
	 * Gets estimated standard error
	 * @return Standard error map
	 */
	public double[][] getStErrorMap(){
		return rgdMapStError;
	}
	
	/**
	 * Loads latitudinal diversity array
	 * @return First column with mean diversity, second column with CI lower bound, third column with CI upper bound
	 */
	public double[][] getLatitudinalDiversity(){
		return rgdLatGradient;
	}
}
